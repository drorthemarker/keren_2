<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Text Synchronizer - Manual File Load</title>
    <style>
        :root { --highlight-color: #FFD700; --primary-blue: #007bff; --mic-active-color: #dc3545; --light-gray: #6c757d; --orange-color: #fd7e14; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f4f4f9; margin: 0; padding: 20px; box-sizing: border-box; }
        .container { width: 90%; max-width: 900px; background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); padding: 20px; margin-top: 15px; }
        #file-selection { width: 90%; max-width: 900px; margin-bottom: 20px; text-align: right; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .file-upload-area { display: flex; justify-content: space-around; gap: 15px; margin-bottom: 20px; }
        #text-display { height: 20vh; overflow-y: auto; border: 1px solid #ddd; padding: 15px; font-size: 24px; line-height: 2.3; margin-bottom: 20px; display: flex; align-items: center; justify-content: center; }
        #text-display span.highlight-chunk { background-color: var(--highlight-color); color: black; border-radius: 4px; }
        .controls { display: flex; justify-content: center; flex-wrap: wrap; gap: 10px; align-items: center; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; background-color: var(--primary-blue); color: white; transition: background-color 0.2s; min-width: 180px; text-align: center;}
        button.upload-btn { background-color: var(--light-gray); flex-grow: 1; }
        button#play-mic-btn.active { background-color: var(--mic-active-color); }
        button#restart-btn { background-color: var(--orange-color); }
        button:hover:not(:disabled) { opacity: 0.85; }
        button:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        .font-controls { display: flex; gap: 5px; }
        .font-controls button { min-width: 45px; font-size: 20px; font-weight: bold; }
        #status { font-size: 16px; color: #333; height: 20px; margin-top: 15px; text-align: center;}
    </style>
</head>
<body>
    <h1>מסנכרן אודיו וטקסט</h1>

    <div id="file-selection">
        <h2>אנא העלה את הקבצים שלך:</h2>
        <div class="file-upload-area">
            <input type="file" id="audio-file-input" accept=".wav,audio/wav" style="display: none;">
            <input type="file" id="timestamp-file-input" accept=".txt,text/plain" style="display: none;">
            <button id="upload-audio-btn" class="upload-btn">בחר קובץ שמע (wav)</button>
            <button id="upload-sync-btn" class="upload-btn">בחר קובץ תזמונים (txt)</button>
        </div>
        <button id="load-files-btn" disabled>טען קבצים</button>
    </div>

    <p id="status">בחר קובץ שמע וקובץ תזמונים כדי להפעיל את כפתור הטעינה.</p>

    <div class="container" style="display: none;">
        <div id="text-display"></div>
        <div class="controls">
            <button id="play-chunk-btn" disabled>נגן מקטע הבא</button>
            <button id="play-mic-btn" disabled>התחל עם מיקרופון</button>
            <button id="restart-btn" disabled>התחל מחדש</button>
            <div class="font-controls">
                <button id="font-decrease-btn" title="הקטן גופן">-</button>
                <button id="font-increase-btn" title="הגדל גופן">+</button>
            </div>
        </div>
    </div>

    <script>
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const isSpeechRecognitionSupported = SpeechRecognition != null;

        const elements = {
            textDisplay: document.getElementById('text-display'),
            playChunkBtn: document.getElementById('play-chunk-btn'),
            playMicBtn: document.getElementById('play-mic-btn'),
            restartBtn: document.getElementById('restart-btn'),
            fontIncreaseBtn: document.getElementById('font-increase-btn'),
            fontDecreaseBtn: document.getElementById('font-decrease-btn'),
            status: document.getElementById('status'),
            container: document.querySelector('.container'),
            loadFilesBtn: document.getElementById('load-files-btn'),
            audioFileInput: document.getElementById('audio-file-input'),
            timestampFileInput: document.getElementById('timestamp-file-input'),
            uploadAudioBtn: document.getElementById('upload-audio-btn'),
            uploadSyncBtn: document.getElementById('upload-sync-btn'),
        };

        let audioContext, audioBuffer, currentChunkSource;
        let recognition, isMicrophoneMode = false;
        let currentFontSize = 24;

        let state = {
            timestamps: [],
            chunkIndex: 0,
        };
        
        window.addEventListener('DOMContentLoaded', () => {
            if (!isSpeechRecognitionSupported) {
                elements.playMicBtn.disabled = true;
                elements.playMicBtn.textContent = 'מיקרופון לא נתמך';
            }
        });

        function checkFilesSelected() {
            const audioFile = elements.audioFileInput.files[0];
            const timestampFile = elements.timestampFileInput.files[0];
            elements.loadFilesBtn.disabled = !(audioFile && timestampFile);
            if (audioFile && timestampFile) {
                 elements.status.textContent = 'קבצים נבחרו. לחץ על "טען קבצים" כדי להמשיך.';
            }
        }

        elements.uploadAudioBtn.addEventListener('click', () => elements.audioFileInput.click());
        elements.uploadSyncBtn.addEventListener('click', () => elements.timestampFileInput.click());
        elements.audioFileInput.addEventListener('change', () => {
            const file = elements.audioFileInput.files[0];
            if (file) elements.uploadAudioBtn.textContent = file.name;
            checkFilesSelected();
        });
        elements.timestampFileInput.addEventListener('change', () => {
            const file = elements.timestampFileInput.files[0];
            if (file) elements.uploadSyncBtn.textContent = file.name;
            checkFilesSelected();
        });

        elements.loadFilesBtn.addEventListener('click', async () => {
            const audioFile = elements.audioFileInput.files[0];
            const timestampFile = elements.timestampFileInput.files[0];
            if (!audioFile || !timestampFile) return;

            resetStateAndUI();
            elements.status.textContent = `טוען קבצים...`;
            elements.container.style.display = 'block';

            try {
                const readFileAsArrayBuffer = (file) => new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });

                const readFileAsText = (file) => new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });

                const [arrayBuffer, timestampText] = await Promise.all([
                    readFileAsArrayBuffer(audioFile),
                    readFileAsText(timestampFile)
                ]);

                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                state.timestamps = parseTimestamps(timestampText);

                elements.playChunkBtn.disabled = false;
                elements.restartBtn.disabled = false;
                if (isSpeechRecognitionSupported) elements.playMicBtn.disabled = false;
                elements.status.textContent = 'מוכן. לחץ על כפתור כדי להתחיל.';
            } catch (error) {
                console.error('Error loading local files:', error);
                elements.status.textContent = `שגיאה בטעינת הקבצים: ${error.message}`;
            }
        });

        function resetStateAndUI() {
            if (isMicrophoneMode) pauseMicrophoneMode();
            if (currentChunkSource) currentChunkSource.stop();
            audioBuffer = null;
            state.timestamps = [];
            state.chunkIndex = 0;
            elements.textDisplay.innerHTML = '';
        }

        function parseTime(timeStr) { let s=0; const m=timeStr.match(/(\d+)m/); if(m)s+=parseInt(m[1])*60; const sec=timeStr.match(/(\d+)s/); if(sec)s+=parseInt(sec[1]); const ms=timeStr.match(/(\d+)ms/); if(ms)s+=parseInt(ms[1])/1000; return s; }
        function parseTimestamps(text) { return text.split('\n').map(line => { const match = line.trim().match(/\[\s*(.*?)\s*-\s*(.*?)\s*\]\s*(.*)/); return match ? { start: parseTime(match[1]), end: parseTime(match[2]), word: match[3] } : null; }).filter(Boolean); }
        
        function calculateNextChunk() {
            const totalWords = state.timestamps.length;
            const startIndex = state.chunkIndex;
            if (startIndex >= totalWords) return { startIdx: -1, endIdx: -1 };

            const minChunkSize = 3;
            const maxChunkSize = 7;
            const wordsRemaining = totalWords - startIndex;
            const SILENCE_THRESHOLD = 0.25;

            // --- REBUILT LOGIC ---

            // 1. If we are near the end, take all remaining words to ensure we finish cleanly.
            if (wordsRemaining <= minChunkSize) {
                return { startIdx: startIndex, endIdx: totalWords - 1 };
            }

            // 2. Search for the best natural break point within our window.
            let breakIndex = -1;
            // We search backwards from the end of the window to find the longest possible natural phrase.
            const searchEndIndex = Math.min(startIndex + maxChunkSize, totalWords);

            for (let i = searchEndIndex - 1; i >= startIndex + 1; i--) { // Ensure at least a 2-word chunk
                const currentWord = state.timestamps[i];
                const previousWord = state.timestamps[i-1];
                
                // Check for a long pause *before* the current word. This is a very strong signal.
                const gap = currentWord.start - previousWord.end;
                if (gap >= SILENCE_THRESHOLD) {
                    breakIndex = i - 1; // Break after the previous word
                    break; 
                }

                // Check for punctuation at the current word. Also a strong signal.
                if (currentWord.word.endsWith(',') || currentWord.word.endsWith('.') || currentWord.word.endsWith('?') || currentWord.word.endsWith('!')) {
                    breakIndex = i;
                    break;
                }
            }
            
            // 3. Decide what chunk to return based on the search.
            if (breakIndex !== -1) {
                // We found a good natural break point. Use it.
                return { startIdx: startIndex, endIdx: breakIndex };
            } else {
                // No natural break was found, so we fall back to a default chunk size.
                // This ensures the app always progresses.
                const defaultEndIndex = startIndex + minChunkSize - 1;
                return { startIdx: startIndex, endIdx: defaultEndIndex };
            }
        }

        function renderChunk(startIdx, endIdx) { 
            elements.textDisplay.innerHTML = ''; 
            if (startIdx === -1) return; 
            for (let i = startIdx; i <= endIdx; i++) { 
                const ts = state.timestamps[i]; 
                const span = document.createElement('span'); 
                span.className = 'word highlight-chunk'; 
                span.textContent = ts.word + '\u00A0'; 
                elements.textDisplay.appendChild(span); 
            } 
        }

        async function processNextChunk(isMicMode = false) {
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            elements.playChunkBtn.disabled = true;
            elements.playMicBtn.disabled = true;
            elements.restartBtn.disabled = true;

            const { startIdx, endIdx } = calculateNextChunk();

            if (startIdx === -1) {
                elements.status.textContent = "הגעת לסוף!";
                if (isMicMode) pauseMicrophoneMode();
                state.chunkIndex = 0;
                elements.textDisplay.innerHTML = '';
                elements.playChunkBtn.disabled = false;
                elements.restartBtn.disabled = false;
                if(isSpeechRecognitionSupported) {
                    elements.playMicBtn.disabled = false;
                    elements.playMicBtn.textContent = 'התחל עם מיקרופון';
                }
                return;
            }

            renderChunk(startIdx, endIdx);

            const PRE_START_OFFSET = 0.1;
            const POST_END_OFFSET = 0.2;
            
            const desiredStartTime = state.timestamps[startIdx].start - PRE_START_OFFSET;
            const desiredStopTime = state.timestamps[endIdx].end + POST_END_OFFSET;

            const safeStartTime = Math.max(0, desiredStartTime);
            const safeStopTime = Math.min(audioBuffer.duration, desiredStopTime);

            const duration = safeStopTime - safeStartTime;

            if (duration <= 0) {
                console.error(`Invalid duration for chunk starting at index ${startIdx}. Skipping.`);
                state.chunkIndex = endIdx + 1;
                requestAnimationFrame(() => processNextChunk(isMicMode));
                return;
            }
            
            if (currentChunkSource) currentChunkSource.stop();
            currentChunkSource = audioContext.createBufferSource();
            currentChunkSource.buffer = audioBuffer;
            currentChunkSource.connect(audioContext.destination);
            
            currentChunkSource.onended = () => {
                if (isMicrophoneMode) {
                    elements.status.textContent = 'תורך, דבר...';
                    recognition.start();
                }
                elements.playChunkBtn.disabled = false;
                elements.restartBtn.disabled = false;
                if (isSpeechRecognitionSupported) {
                    elements.playMicBtn.disabled = false; 
                }
            };
            
            elements.status.textContent = 'מקשיבים לאודיו...';
            currentChunkSource.start(0, safeStartTime, duration);
            state.chunkIndex = endIdx + 1;
        }

        elements.playChunkBtn.addEventListener('click', () => {
            if (isMicrophoneMode || !audioContext || !audioBuffer) return;
            processNextChunk(false);
        });

        function setupSpeechRecognition() {
            if (recognition) return;
            recognition = new SpeechRecognition();
            recognition.lang = 'he-IL';
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.onspeechend = () => {
                elements.status.textContent = 'הבנתי, מקדם למקטע הבא...';
                setTimeout(() => processNextChunk(true), 500);
            };
            recognition.onerror = (event) => {
                console.error('Speech recognition error', event.error);
                if (event.error === 'no-speech' && isMicrophoneMode) {
                    elements.status.textContent = 'לא שמעתי כלום, נסה שוב...';
                    recognition.start();
                } else if (event.error === 'not-allowed') {
                    elements.status.textContent = 'נדחתה הרשאת גישה למיקרופון.';
                    pauseMicrophoneMode();
                }
            };
        }

        function startOrResumeMicrophoneMode() {
            isMicrophoneMode = true;
            elements.playMicBtn.textContent = 'השהה מיקרופון';
            elements.playMicBtn.classList.add('active');
            setupSpeechRecognition();
            processNextChunk(true);
        }

        function pauseMicrophoneMode() {
            isMicrophoneMode = false;
            if (recognition) recognition.abort();
            if (currentChunkSource) currentChunkSource.stop();
            
            elements.playMicBtn.textContent = 'המשך עם מיקרופון';
            elements.playMicBtn.classList.remove('active');
            elements.status.textContent = 'מצב מיקרופון הושהה.';
            
            const filesLoaded = audioBuffer && state.timestamps.length > 0;
            elements.playChunkBtn.disabled = !filesLoaded;
            elements.restartBtn.disabled = !filesLoaded;
            if (isSpeechRecognitionSupported) elements.playMicBtn.disabled = !filesLoaded;
        }

        function restartProcess() {
            if (isMicrophoneMode) pauseMicrophoneMode();
            state.chunkIndex = 0;
            elements.textDisplay.innerHTML = '';
            elements.status.textContent = 'התהליך אופס. לחץ על "התחל" כדי להתחיל מההתחלה.';
            elements.playMicBtn.textContent = 'התחל עם מיקרופון';
        }
        elements.restartBtn.addEventListener('click', restartProcess);

        elements.playMicBtn.addEventListener('click', () => {
            if (isMicrophoneMode) {
                pauseMicrophoneMode();
            } else {
                startOrResumeMicrophoneMode();
            }
        });
        
        elements.fontIncreaseBtn.addEventListener('click', () => { if (currentFontSize >= 100) return; currentFontSize += 2; elements.textDisplay.style.fontSize = `${currentFontSize}px`; });
        elements.fontDecreaseBtn.addEventListener('click', () => { if (currentFontSize <= 12) return; currentFontSize -= 2; elements.textDisplay.style.fontSize = `${currentFontSize}px`; });
    </script>
</body>
</html>
